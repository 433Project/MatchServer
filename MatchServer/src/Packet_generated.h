// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_PACKET_PACKETGENERATOR_H_
#define FLATBUFFERS_GENERATED_PACKET_PACKETGENERATOR_H_

#include "flatbuffers/flatbuffers.h"

namespace fb {

	struct Header;

	struct Body;

	struct Packet;

	enum SrcDstType {
		SrcDstType_MATCHING_SERVER = 0,
		SrcDstType_MATCHING_CLIENT = 1,
		SrcDstType_ROOM_MANAGER = 2,
		SrcDstType_PACKET_GENERATOR = 3,
		SrcDstType_MONITORING_SERVER = 4,
		SrcDstType_CONFIG_SERVER = 5,
		SrcDstType_CONNECTION_SERVER = 6,
		SrcDstType_MIN = SrcDstType_MATCHING_SERVER,
		SrcDstType_MAX = SrcDstType_CONNECTION_SERVER
	};

	inline const char **EnumNamesSrcDstType() {
		static const char *names[] = { "MATCHING_SERVER", "MATCHING_CLIENT", "ROOM_MANAGER", "PACKET_GENERATOR", "MONITORING_SERVER", "CONFIG_SERVER", "CONNECTION_SERVER", nullptr };
		return names;
	}

	inline const char *EnumNameSrcDstType(SrcDstType e) { return EnumNamesSrcDstType()[static_cast<int>(e)]; }

	enum Command {
		Command_MATCH_REQUEST = 0,
		Command_MATCH_COMPLET = 1,
		Command_LATENCY = 2,
		Command_HEALTH_CHECK = 3,
		Command_MSLIST_REQUEST = 4,
		Command_PG_START = 5,
		Command_PG_END = 6,
		Command_MIN = Command_MATCH_REQUEST,
		Command_MAX = Command_PG_END
	};

	inline const char **EnumNamesCommand() {
		static const char *names[] = { "MATCH_REQUEST", "MATCH_COMPLET", "LATENCY", "HEALTH_CHECK", "MSLIST_REQUEST", "PG_START", "PG_END", nullptr };
		return names;
	}

	inline const char *EnumNameCommand(Command e) { return EnumNamesCommand()[static_cast<int>(e)]; }

	struct Header FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
		enum {
			VT_LENGTH = 4,
			VT_SRCTYPE = 6,
			VT_SRCCODE = 8,
			VT_DSTTYPE = 10,
			VT_DSTCODE = 12
		};
		int32_t length() const { return GetField<int32_t>(VT_LENGTH, 0); }
		SrcDstType srcType() const { return static_cast<SrcDstType>(GetField<int32_t>(VT_SRCTYPE, 0)); }
		int32_t srcCode() const { return GetField<int32_t>(VT_SRCCODE, 0); }
		SrcDstType dstType() const { return static_cast<SrcDstType>(GetField<int32_t>(VT_DSTTYPE, 0)); }
		int32_t dstCode() const { return GetField<int32_t>(VT_DSTCODE, 0); }
		bool Verify(flatbuffers::Verifier &verifier) const {
			return VerifyTableStart(verifier) &&
				VerifyField<int32_t>(verifier, VT_LENGTH) &&
				VerifyField<int32_t>(verifier, VT_SRCTYPE) &&
				VerifyField<int32_t>(verifier, VT_SRCCODE) &&
				VerifyField<int32_t>(verifier, VT_DSTTYPE) &&
				VerifyField<int32_t>(verifier, VT_DSTCODE) &&
				verifier.EndTable();
		}
	};

	struct HeaderBuilder {
		flatbuffers::FlatBufferBuilder &fbb_;
		flatbuffers::uoffset_t start_;
		void add_length(int32_t length) { fbb_.AddElement<int32_t>(Header::VT_LENGTH, length, 0); }
		void add_srcType(SrcDstType srcType) { fbb_.AddElement<int32_t>(Header::VT_SRCTYPE, static_cast<int32_t>(srcType), 0); }
		void add_srcCode(int32_t srcCode) { fbb_.AddElement<int32_t>(Header::VT_SRCCODE, srcCode, 0); }
		void add_dstType(SrcDstType dstType) { fbb_.AddElement<int32_t>(Header::VT_DSTTYPE, static_cast<int32_t>(dstType), 0); }
		void add_dstCode(int32_t dstCode) { fbb_.AddElement<int32_t>(Header::VT_DSTCODE, dstCode, 0); }
		HeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
		HeaderBuilder &operator=(const HeaderBuilder &);
		flatbuffers::Offset<Header> Finish() {
			auto o = flatbuffers::Offset<Header>(fbb_.EndTable(start_, 5));
			return o;
		}
	};

	inline flatbuffers::Offset<Header> CreateHeader(flatbuffers::FlatBufferBuilder &_fbb,
		int32_t length = 0,
		SrcDstType srcType = SrcDstType_MATCHING_SERVER,
		int32_t srcCode = 0,
		SrcDstType dstType = SrcDstType_MATCHING_SERVER,
		int32_t dstCode = 0) {
		HeaderBuilder builder_(_fbb);
		builder_.add_dstCode(dstCode);
		builder_.add_dstType(dstType);
		builder_.add_srcCode(srcCode);
		builder_.add_srcType(srcType);
		builder_.add_length(length);
		return builder_.Finish();
	}

	struct Body FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
		enum {
			VT_CMD = 4,
			VT_DATA = 6
		};
		Command cmd() const { return static_cast<Command>(GetField<int32_t>(VT_CMD, 0)); }
		const flatbuffers::String *data() const { return GetPointer<const flatbuffers::String *>(VT_DATA); }
		bool Verify(flatbuffers::Verifier &verifier) const {
			return VerifyTableStart(verifier) &&
				VerifyField<int32_t>(verifier, VT_CMD) &&
				VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
				verifier.Verify(data()) &&
				verifier.EndTable();
		}
	};

	struct BodyBuilder {
		flatbuffers::FlatBufferBuilder &fbb_;
		flatbuffers::uoffset_t start_;
		void add_cmd(Command cmd) { fbb_.AddElement<int32_t>(Body::VT_CMD, static_cast<int32_t>(cmd), 0); }
		void add_data(flatbuffers::Offset<flatbuffers::String> data) { fbb_.AddOffset(Body::VT_DATA, data); }
		BodyBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
		BodyBuilder &operator=(const BodyBuilder &);
		flatbuffers::Offset<Body> Finish() {
			auto o = flatbuffers::Offset<Body>(fbb_.EndTable(start_, 2));
			return o;
		}
	};

	inline flatbuffers::Offset<Body> CreateBody(flatbuffers::FlatBufferBuilder &_fbb,
		Command cmd = Command_MATCH_REQUEST,
		flatbuffers::Offset<flatbuffers::String> data = 0) {
		BodyBuilder builder_(_fbb);
		builder_.add_data(data);
		builder_.add_cmd(cmd);
		return builder_.Finish();
	}

	inline flatbuffers::Offset<Body> CreateBodyDirect(flatbuffers::FlatBufferBuilder &_fbb,
		Command cmd = Command_MATCH_REQUEST,
		const char *data = nullptr) {
		return CreateBody(_fbb, cmd, data ? _fbb.CreateString(data) : 0);
	}

	struct Packet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
		enum {
			VT_HEADER = 4,
			VT_BODY = 6
		};
		const Header *header() const { return GetPointer<const Header *>(VT_HEADER); }
		const Body *body() const { return GetPointer<const Body *>(VT_BODY); }
		bool Verify(flatbuffers::Verifier &verifier) const {
			return VerifyTableStart(verifier) &&
				VerifyField<flatbuffers::uoffset_t>(verifier, VT_HEADER) &&
				verifier.VerifyTable(header()) &&
				VerifyField<flatbuffers::uoffset_t>(verifier, VT_BODY) &&
				verifier.VerifyTable(body()) &&
				verifier.EndTable();
		}
	};

	struct PacketBuilder {
		flatbuffers::FlatBufferBuilder &fbb_;
		flatbuffers::uoffset_t start_;
		void add_header(flatbuffers::Offset<Header> header) { fbb_.AddOffset(Packet::VT_HEADER, header); }
		void add_body(flatbuffers::Offset<Body> body) { fbb_.AddOffset(Packet::VT_BODY, body); }
		PacketBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
		PacketBuilder &operator=(const PacketBuilder &);
		flatbuffers::Offset<Packet> Finish() {
			auto o = flatbuffers::Offset<Packet>(fbb_.EndTable(start_, 2));
			return o;
		}
	};

	inline flatbuffers::Offset<Packet> CreatePacket(flatbuffers::FlatBufferBuilder &_fbb,
		flatbuffers::Offset<Header> header = 0,
		flatbuffers::Offset<Body> body = 0) {
		PacketBuilder builder_(_fbb);
		builder_.add_body(body);
		builder_.add_header(header);
		return builder_.Finish();
	}

	inline const fb::Packet *GetPacket(const void *buf) { return flatbuffers::GetRoot<fb::Packet>(buf); }

	inline bool VerifyPacketBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<fb::Packet>(nullptr); }

	inline void FinishPacketBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<fb::Packet> root) { fbb.Finish(root); }

}  // namespace PacketGenerator

#endif  // FLATBUFFERS_GENERATED_PACKET_PACKETGENERATOR_H_
